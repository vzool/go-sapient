package sapient

import (
	"bytes"
	"testing"
)

// Generated by original Sapient written in PHP
// Check https://github.com/paragonie/sapient
var testEncryptionKeys = []string{
	"DgCko0S08-cv_8dgKA8qa3diWzolc22LS4cqpDmEgW0=",
	"BwkQJh2qTeRyqDjw3y1LhZD6npBGVEWNolUVwHippiI=",
	"VjKu_Gw9QwG5PMRlEvFomCrRDsD989UqXXZz90hHb7o=",
	"g9QMXCKuC8MDFp3eLQ6Km_Ga8GPzxujfm-zkUkRlBUQ=",
	"61Hg8p2qkvpQmvpGJSYWK4OK_hqY5tFe82kjUINq7Lo=",
	"16dW0_nGhqrZ4Xx8MhTFwHVIs9ff8mkIv8gSQcDnz3k=",
	"Y856sYOhKOCrU7q3YzfRJGlVegVIuZ-Ok8xMYYG6GvY=",
	"SOz1D_dBtF7Ok0osbRff7h_42-tfBNe2M3YQfdXSgSU=",
	"lxrgypvkiKOQVH-HbPFxjwPjiZOh9qh1spflfI7T8ZI=",
	"SJ3qev6o50mWi0zigLJaS2VLrcHJYjMdB-v3QSJo8OA=",
}

func TestSharedEncryptionKey_KeyGeneration(t *testing.T) {

	// test for 10 times

	for i := 0; i < 10; i++ {

		// Generate new key at the constructor

		key := NewSharedEncryptionKey(nil)

		sharedEncryptionVerify(key, t)

		// Load key in string format
		key = NewSharedEncryptionKey(testEncryptionKeys[i])

		if key.String() != testEncryptionKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testEncryptionKeys[i],
			)
		}

		sharedEncryptionVerify(key, t)

		// Load key in bytes format
		sk, err := Base64UrlDecode(testEncryptionKeys[i])

		if err != nil {
			t.Error("Failed to decode base64url:", err.Error())
		}

		key = NewSharedEncryptionKey(sk)

		if key.String() != testEncryptionKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testEncryptionKeys[i],
			)
		}

		sharedEncryptionVerify(key, t)
	}
}

func TestEncryptWithSharedKey_EncryptThenDecrypt(t *testing.T) {

	key := NewSharedEncryptionKey(nil)

	cipher := key.Encrypt(originalMessage)

	if cipher == "" {
		t.Error("cipher output is empty")
	}

	decryptedMessage := key.Decrypt(cipher)

	if decryptedMessage == nil {
		t.Error("decrypted Message output is nil")
	}

	if !bytes.Equal(decryptedMessage, originalMessage) {

		t.Error("decrypted Message not Equal original Message")
	}
}

func TestSharedEncryptionKey_LoadKeys(t *testing.T) {

	for _, encoded := range testEncryptionKeys {

		// Test: Load key at instance creation
		key := NewSharedEncryptionKey(encoded)

		// Test: Load key after instance creation
		key.Load(encoded)

		// Test: External checking and Byte by Byte match
		sharedEncryptionVerify(key, t)
	}
}

func sharedEncryptionVerify(key *SharedEncryptionKey, t *testing.T) {

	bytesSize := SharedEncryptionKeyBytesSize
	encodedSize := SharedEncryptionKeyEncodedSize

	if size := len(key.Bytes()); size < bytesSize || size > bytesSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, bytesSize)
	}

	encoded := key.String()

	if size := len(encoded); size < encodedSize || size > encodedSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, encodedSize)
	}

	decoded, err := Base64UrlDecode(encoded)

	if err != nil {

		t.Error("Failed to decode generated key", err.Error())
	}

	// Match bytes by bytes after encoding

	for i, b := range decoded {

		if key.Bytes()[i] != b {

			t.Errorf("Byte(%v) missmatch with original Byte(%v)", b, key.Bytes()[i])
		}
	}
}
