package sapient

import "testing"

// Generated by original Sapient written in PHP
// Check https://github.com/paragonie/sapient
var testSigningPublicKeys = []string{
	"s5o453gjJUZCYie68Xq8pxlyyfJ4UUGfZRYmM7UsuWA=",
	"S2tyxKh6K7LL3uP20vnqEEUf4yIATYskUIl1EUdVJJo=",
	"AMGub6KO52zXPIM4sc-AP4NgotdkEUhA-TgX-aC9ma8=",
	"7q2s0BTHuq04XMCWbnEDKF_MeY5Rp2uFcMIYRtN1mbk=",
	"34VMrZErfz3GB8pz-gfRSDf6qHY25MfFX96pIPcVr70=",
	"nMHcJv9lnBxwVtG8phejXw306Ils05ggzePrPlZY8wM=",
	"rkUBttVBQmH3f8dKXO94T3woGZlaTWX0f6UV5GLJjdE=",
	"BKTfs75LNJUbl-DVif-qjEKF8_ACn2Rxd5CEUXBB3KY=",
	"GC8gb5pp2Kr6dH3B0SeUh5rpE5-CsIWCrj_iPKo4XzA=",
	"mhTvtCSEHZKiAHVqpQnT462HRRSazKksxKzXaitCBPw=",
}

func TestSigningPublicKey(t *testing.T) {

	// test for 10 times

	for i := 0; i < 10; i++ {

		// Load key in string format
		key := NewSigningPublicKey(testSigningPublicKeys[i])

		if key.String() != testSigningPublicKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testSigningPublicKeys[i],
			)
		}

		// Load key in bytes format
		sk, err := Base64UrlDecode(testSigningPublicKeys[i])

		if err != nil {
			t.Error("Failed to decode base64url:", err.Error())
		}

		key = NewSigningPublicKey(sk)

		if key.String() != testSigningPublicKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testSigningPublicKeys[i],
			)
		}

		verifySigningPublicKey(key, t)
	}
}

func TestSigningPublicKey_LoadKeys(t *testing.T) {

	for _, encoded := range testSigningPublicKeys {

		// Test: Load key at instance creation
		key := NewSigningPublicKey(encoded)

		// Test: Load key after instance creation
		key.Load(encoded)

		// Test: External checking and Byte by Byte match
		verifySigningPublicKey(key, t)
	}
}

func verifySigningPublicKey(key *SigningPublicKey, t *testing.T) {

	bytesSize := SigningPublicKeyBytesSize
	encodedSize := SigningPublicKeyEncodedSize

	if size := len(key.Bytes()); size < bytesSize || size > bytesSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, bytesSize)
	}

	encoded := key.String()

	if size := len(encoded); size < encodedSize || size > encodedSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, encodedSize)
	}

	decoded, err := Base64UrlDecode(encoded)

	if err != nil {

		t.Error("Failed to decode generated key", err.Error())
	}

	// Match bytes by bytes after encoding

	for i, b := range decoded {

		if key.Bytes()[i] != b {

			t.Errorf("Byte(%v) missmatch with original Byte(%v)", b, key.Bytes()[i])
		}
	}
}
