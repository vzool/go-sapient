package sapient

import (
	"testing"
)

// Generated by original Sapient written in PHP
// Check https://github.com/paragonie/sapient
var testSigningSecretKeys = []string{
	"YXh13GLZzaQRNIIdoYAwymqCqsLjaKfk9bR_Il7H0c0nVjUUBNklDy7OZRJgE8Cz_VWHENAOTJo_sKSiJGVFgw==",
	"8TTI7LTDcSeacGF5d0qDxex28W8I9OwPJiQ01wd8O8XTIsExj8kWInWqxOERoZaYGqcqqKHaeW8SO9WVoQQGXA==",
	"iqSEc6xh0INJV3NYVhJ9sJC82dMD3V9Ylkm9n0mgyvNTjUZjUZFJ2inQ61RKJLmP_BoqFIZu-WlgkJtpRrwzfA==",
	"oIqIfZkxdTKjEcNwyUNDdjC1cZRlW1J7xjjOqB2jGpffiT1Wd41EYyTgfOEEnNvB-ZoZZ8-_K1oVeTarVuIHiA==",
	"Ogj9Me-5tdNg6xbE4Z4eivgOEoE68yn-wz5NBjGG3VDr_NKppT_saXZYWxcP7dH1YuYiU7MnahEBvJfre3qHMw==",
	"iwjdf4yezshQX4zCNLjxgccCT6iMpio8HBZIlTgRxyp2-erulIZUuqg6TSr-131z5GbdxJIIzAkUx7uqq9V4pA==",
	"I55p0PseDo3hr2nRW3rAC_cOhFlKBzcPmr_SjAfHkiM4t7oReixBgM-3ZNrMPnlr0vvr8HNAqYGMQiDuYfA0Lg==",
	"N4ukfppDWNHwJJ0h1K1hMFw_RB-J-GX__iOpQYRXa18LM9E8-Jz0iQLMrjdkQOQwR-EtpX0iGzt97LW6RWOeDg==",
	"mALI4yDf0LT6-cUgwjyc9i9I7nc8-VxrVQpPGlueYJRXquVxIUV6EmIeA40Dy75_lnMdfPEEypZAmOcHc1v1_g==",
	"ORGnDjgbgVpVzf-6nvcI8pCSwXEmxPlnuC6fqkoPegP2fI9xoz-yuBhyCgw4e54xCHmizoDf0hsrdUcJMyUpNA==",
}

// Those Public Keys are derived form upper Secret Key,
// every index in public keys array is belong to
// the same index in secret keys array.
var testDerivedPublicKeys = []string{
	"jpKz5zYpVfeNxQYmkOmUIAa8lZpH2RlK2ZPiG_XEnZI=",
	"2_4mDFGD4ORyhvDBFEsQooqyFw2qNWSm5CmV1gA3bLA=",
	"m7Z_FBuJp0e3InVwjxzrODXJsbNBgKiJt6OZpItnxZ8=",
	"T6YwsHs8J0-X9b_Hramh_P7zM6RGIJtqTv3ojTRlhbU=",
	"S2WLc520Wxy8DZyvkuMMthUuzGP_Psql4uLL3980OqE=",
	"gRn_GQ5XBIDfF_FEbumtr9bLP5ujCcrQKKhqw0NDSko=",
	"FMOdw5ypsX91X9e7gB1N-haUYu_33loyvVnEFB48tK4=",
	"5khHLhqPy1O2D8NWoPZDW9fMIwS0dv-aU5WliWcWnW8=",
	"Il8DW4HyTAwiKYG-Nu4dMNnuc8C7bNB8is0CYYyv2Oc=",
	"1I0jEJIQ4MxmnH_KUbA1IkK2BgGRVuxjMLTZpxRT35E=",
}

// Random data
var testData = []string{
	"BB6D4B7A-3757-4934-82EE-0DBB7749850C",
	"B8ACFCE2-5E26-4DB9-B407-B02BC1E059BC",
	"5015E190-36A5-4393-9E4D-FA0363A58334",
	"9D215D7D-58F9-4628-B5DA-D0E47C2737B4",
	"6961D07A-0B88-42C7-ADCA-0498B7BB6A94",
	"7BD173C4-5F6F-4082-AAF1-F3C70F7EC30E",
	"C3C105FD-32F4-406E-BCFE-4A6DE9ACAB5C",
	"8B04C1E0-BA9C-42C3-9ADD-2BC095D19295",
	"1FE3BBC9-B54A-467C-A2B7-9B398176F0B5",
	"259F55B7-B5B2-4D6C-A0DC-1AFFF8DE027A",
	"22F1E7C7-1B2C-4DF5-9C04-2AC6CDC61CB2",
	"F1D623B4-46FF-434F-8BC8-91685423F440",
	"864CA30B-4705-455C-BDF3-C41548F6FF1A",
}

// Those signatures were genereted by above secret keys for the above data.
// Again every index belong to other data related in other arrays in the same index.
var testDataSignature = []string{
	"vVhhKl3ssodL_MTruPYb4i0kzlPcL0P416HeWZYiMQUaoxNTnbwn6dAFr68wAc6k56HC2sKYalVIPyzPx_BIBw==",
	"kUsGiQC0ug2EDaumTgbX-Nl7-z5GDL6gJ2akkEs_5WI9gZJdbnRMFWSDN70bvJr-G6LlmjIUjnx_ZJeAP772Aw==",
	"oxS58DiKW0COHlXlHqNUwvCwQHZar_JKHO_NKEEWZe6LgtCrJOkkXsVUSzzjNkC4vAMBohLUFx4L5xx1vztpAg==",
	"gy_mnxp0OIOow-3z3Vjh9YFh37sndX7JHqTqHjijgTSqP9zvsN-6OszsYLAbGw6AAZGzcNFiwNdvZrjDNBuuBw==",
	"EEEkvFT9yD2CPZ7-HxWNJBgatB10eOYkfNa3u8OeekytUiBVmBIkKiscmE4JfxcwlG3kk-urnTtHvQdgc15oAQ==",
	"YZpZ_xVU806uZqdEg8bgjdX3Gt-atY05HjqDKt7MSpjso2_SlW5sb4LG4U4rpI-HbeyueGfHZzz7Y7cHZ9rEAg==",
	"JCowChu59-S2JXYaQrOEiYqJ2stdPSrYkZxukmW13AtvmizWLOqpiNnRLr43rorG2_CVhG42cpJkeLOcJPe3DQ==",
	"iYIWSZ24GiutlCKvUFK2yN2Q_p008gk8LLSEDrXGQPbLw6p6lPTmsqhVDrU9vNUIk8xU-VmtMGtfVImuAlyfCg==",
	"2ro8Niy13XciTr7XotZVzZsXCN1Z-0RhJQMozOz9_UpephNrpN4MgUBxbDWWLtNzPxQU20bhxgvyoLYkd79NBA==",
	"mIYtU7gDzVZ2sBx3_zLBaKa1a2gfStaqiNdp8mpSotrWxThRQBG3Oub9f_J_J3A7jC7WlcZljLlJhq91EAMMBA==",
}

func TestSigningSecretKey_LoadByConstructors(t *testing.T) {

	// test for 10 times

	for i := 0; i < 10; i++ {

		// TEST: Load key in string format
		key := NewSigningSecretKey(testSigningSecretKeys[i])

		if key.String() != testSigningSecretKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testSigningSecretKeys[i],
			)
		}

		// TEST: Load key in bytes format
		sk, err := Base64UrlDecode(testSigningSecretKeys[i])

		if err != nil {
			t.Error("Failed to decode base64url:", err.Error())
		}

		key = NewSigningSecretKey(sk)

		if key.String() != testSigningSecretKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testSigningSecretKeys[i],
			)
		}

		verifySigningSecretKey(key, t)
	}
}

func TestSigningSecretKey_LoadKeys(t *testing.T) {

	for index, encoded := range testSigningSecretKeys {

		// Test: Load key at instance creation

		privateKey := NewSigningSecretKey(nil)

		privateKey.Load(encoded)

		// Test: Load key after instance creation

		publicKey := privateKey.PublicKey()

		if publicKey.String() != testDerivedPublicKeys[index] {

			t.Errorf("Public Key missmatch\ngenerated(%v)\noriginal(%v)",
				publicKey,
				testDerivedPublicKeys[index],
			)

			break
		}

		// Test: check if final sercet key are the same
		if privateKey.String() != testSigningSecretKeys[index] {

			t.Errorf("Secret Key missmatch\ngenerated(%v)\noriginal(%v)",
				privateKey,
				testSigningSecretKeys[index],
			)

			break
		}

		// Test: External checking and Byte by Byte match
		verifySigningSecretKey(privateKey, t)
	}
}

func TestSigningSecretKey_SigningAndVerify(t *testing.T) {

	for i, sk := range testSigningSecretKeys {

		message := []byte(testData[i])

		key := NewSigningSecretKey(sk)

		signature := key.Sign(message)

		if signature == nil {

			t.Error("Failed to generate signature, it is empty")
		}

		if size := len(signature); size != SigningSecretKeyBytesSize {

			t.Errorf("Failed to generated signature is %v less than expected %v", size, SigningSecretKeyBytesSize)
		}

		// Verify Signature

		// Test: match generated signature with provided ones
		if sig := Base64UrlEncode(signature); sig != testDataSignature[i] && sig+"==" != testDataSignature[i] {

			t.Errorf("Signature missmatch\n%v\n%v", sig, testDataSignature[i])
		}

		// Test: generate own signature
		if !key.PublicKey().Verify(message, signature) {

			t.Error("Signature failed to be verified")
		}

		sentSignature, err := Base64UrlDecode(testDataSignature[i])

		if err != nil {
			t.Error(err.Error())
		}

		for i = 0; i < len(sentSignature); i++ {

			if x, y := signature[i], sentSignature[i]; x != y {
				t.Errorf("Byte missmatch(%v)!= (%v)", x, y)
			}
		}
	}
}

func verifySigningSecretKey(key *SigningSecretKey, t *testing.T) {

	bytesSize := SigningSecretKeyBytesSize
	encodedSize := SigningSecretKeyEncodedSize

	if size := len(key.Bytes()); size < bytesSize || size > bytesSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, bytesSize)
	}

	encoded := key.String()

	if size := len(encoded); size < encodedSize || size > encodedSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, encodedSize)
	}

	decoded, err := Base64UrlDecode(encoded)

	if err != nil {

		t.Error("Failed to decode generated key", err.Error())
	}

	// Match bytes by bytes after encoding

	for i, b := range decoded {

		if key.Bytes()[i] != b {

			t.Errorf("Byte(%v) missmatch with original Byte(%v)", b, key.Bytes()[i])
		}
	}
}
