package sapient

import "testing"

// Generated by original Sapient written in PHP
// Check https://github.com/paragonie/sapient
var testAuthKeys = []string{
	"V4sEA8APtMPbzgwQa19_GJRhNXA-ilwvCp6YaVduB6Q=",
	"AIQYfW9Y71JNvP1Rj_B_tlHqEipG8saS8xzSAD7ak1o=",
	"fzOFTeVWFxfVTOTorLfOjGvj6oRItRQMjdZ6MudU2rM=",
	"AzgxVXn3WWriA4JaEZ0AlgZywmZSqLTedRSFXfWI2WQ=",
	"gj9kAQ6-YA7-y_efkwTdaxKXlwFu5Nf85ZLY1cNJy2s=",
	"bI-OkWDxLKClH3Cm3bfqJo0qDkcjtWVNnQTIP4ugXWM=",
	"6i2c19vwsWj_o0B2jkspB1V30x2uHY3qBXUmjA13LrU=",
	"dzOKc7VBdRHQv_pj_8dA_cU6wQax-K5i6WgDoqiD-28=",
	"vitocY63-FQPDF_Vs3HhW-ulVwRDi7iLm3867gfnu1w=",
	"eXk7UKoV3zGi2TQZ7Ws4iDQEuK5SsleX5zVJ-8GH954=",
}

func TestSharedAuthenticationKey_KeyGeneration(t *testing.T) {

	// test for 10 times

	for i := 0; i < 10; i++ {

		// Generate new key at the constructor

		key := NewSharedAuthenticationKey(nil)

		sharedAuthenticationVerify(key, t)

		// Load key in string format
		key = NewSharedAuthenticationKey(testAuthKeys[i])

		if key.String() != testAuthKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testAuthKeys[i],
			)
		}

		sharedAuthenticationVerify(key, t)

		// Load key in bytes format
		sk, err := Base64UrlDecode(testAuthKeys[i])

		if err != nil {
			t.Error("Failed to decode base64url:", err.Error())
		}

		key = NewSharedAuthenticationKey(sk)

		if key.String() != testAuthKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testAuthKeys[i],
			)
		}

		sharedAuthenticationVerify(key, t)
	}
}

func TestAuthenticateWithSharedKey_AuthenticateThenVerify(t *testing.T) {

	key := NewSharedAuthenticationKey(nil)

	clientHeader, clientAuth := key.Authenticate(originalMessage)

	if clientHeader == "" {
		t.Error("clientHeader output is nil")
	}

	if clientHeader != HeaderAuthName {
		t.Error("clientHeader not match")
	}

	if clientAuth == "" {
		t.Error("clientAuth output is nil")
	}

	if !key.Verify(clientAuth, originalMessage) {

		t.Error("Authentication has failed")
	}
}

func TestAuthenticateWithSharedKey_LoadKeys(t *testing.T) {

	for _, encoded := range testAuthKeys {

		// Test: Load key at instance creation
		key := NewSharedAuthenticationKey(encoded)

		// Test: Load key after instance creation
		key.Load(encoded)

		// Test: External checking and Byte by Byte match
		sharedAuthenticationVerify(key, t)
	}
}

func sharedAuthenticationVerify(key *SharedAuthenticationKey, t *testing.T) {

	bytesSize := SharedAuthenticationKeyBytesSize
	encodedSize := SharedAuthenticationKeyEncodedSize

	if size := len(key.Bytes()); size < bytesSize || size > bytesSize {

		t.Errorf("Key Size(%v) not match constant value(%v)", size, bytesSize)
	}

	encoded := key.String()

	if size := len(encoded); size < encodedSize || size > encodedSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, encodedSize)
	}

	decoded, err := Base64UrlDecode(encoded)

	if err != nil {

		t.Error("Failed to decode generated key", err.Error())
	}

	// Match bytes by bytes after encoding

	for i, b := range decoded {

		if key.Bytes()[i] != b {

			t.Errorf("Byte(%v) missmatch with original Byte(%v)", b, key.Bytes()[i])
		}
	}
}
