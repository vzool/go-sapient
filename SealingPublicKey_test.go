package sapient

import "testing"

// Generated by original Sapient written in PHP
// Check https://github.com/paragonie/sapient
var testSealingPublicKeys = []string{
	"Y8BTArWIHgA0KAyEP15MPGCTlOhyWa1-SGMwWkVHDwE=",
	"zEPhLAOVt3dShk6anaLcqmdZ1mT3vn_3EOo9ZQ0DT7s=",
	"X3Wq2kpxqe2KXScCgeC0a6qLqiQ5wRkoDuGcschdf-o=",
	"hmiFUz5FDXYOBiymFW4-F8tEymJAOzedHN0E69PzOL8=",
	"1mMxjAcbSiX6U9PijzagIjYdLzlKPf5sEk2Fj_0MnOc=",
	"PG0BqFUrmi1YjTzSWhq_9DV0Nu2i2NUVyrNULR3LH4w=",
	"bfeJzKObNQk-Ztc1wmsQ8DwJL8cc8_MBp289QEUxl9A=",
	"E7Y0rX_RSWH0HGzmLcBxbNm_xz2Xzrq2qQOHBumr0dA=",
	"z2jQbT3Hby235BjDVkF_gNp_MjcEuUgaWQL6U7b7Xrc=",
	"97CVhBJdffMgE2o0r6Kl_R20tH2kQqahpZW4_iu3-WQ=",
}

func TestSealingPublicKey(t *testing.T) {

	// test for 10 times

	for i := 0; i < 10; i++ {

		// Generate new key at the constructor

		key := NewSealingPublicKey(nil)

		verifySealingPublicKey(key, t)

		// Load key in string format
		key = NewSealingPublicKey(testSealingPublicKeys[i])

		if key.String() != testSealingPublicKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testSealingPublicKeys[i],
			)
		}

		verifySealingPublicKey(key, t)

		// Load key in bytes format
		sk, err := Base64UrlDecode(testSealingPublicKeys[i])

		if err != nil {
			t.Error("Failed to decode base64url:", err.Error())
		}

		key = NewSealingPublicKey(sk)

		if key.String() != testSealingPublicKeys[i] {

			t.Errorf("Keys loaded via constructor failed - insideKeyObject(%v) : given(%v)",
				key.String(),
				testSealingPublicKeys[i],
			)
		}

		verifySealingPublicKey(key, t)
	}
}

func TestSealingPublicKey_LoadKeys(t *testing.T) {

	for _, encoded := range testSealingPublicKeys {

		// Test: Load key at instance creation
		key := NewSealingPublicKey(encoded)

		// Test: Load key after instance creation
		key.Load(encoded)

		// Test: External checking and Byte by Byte match
		verifySealingPublicKey(key, t)
	}
}

func verifySealingPublicKey(key *SealingPublicKey, t *testing.T) {

	bytesSize := SealingPublicKeyBytesSize
	encodedSize := SealingPublicKeyEncodedSize

	if size := len(key.Bytes()); size < bytesSize || size > bytesSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, bytesSize)
	}

	encoded := key.String()

	if size := len(encoded); size < encodedSize || size > encodedSize {
		t.Errorf("Key Size(%v) not match constant value(%v)", size, encodedSize)
	}

	decoded, err := Base64UrlDecode(encoded)

	if err != nil {

		t.Error("Failed to decode generated key", err.Error())
	}

	// Match bytes by bytes after encoding

	for i, b := range decoded {

		if key.Bytes()[i] != b {

			t.Errorf("Byte(%v) missmatch with original Byte(%v)", b, key.Bytes()[i])
		}
	}
}
